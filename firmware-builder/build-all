#!/usr/bin/perl

use warnings;
use strict;
use IPC::Run;
use Cwd qw/abs_path cwd/;


my %args = (@ARGV);



if ( !$args{'--tag'} ) {
    die "You need to specifiy a tag or branch name that exists on all four repos in order to build.\n";
}

my %repos = (
    attiny_bootloader  => 'git://github.com/keyboardio/attiny_i2c_bootloader',
    attiny_firmware    => 'git://github.com/keyboardio/avr_keyscanner',
    arduino_boards     => 'git://github.com/keyboardio/Arduino-Boards',
    "Model01-Firmware" => 'git://github.com/keyboardio/Model01-Firmware'
);

my %git_tags;

my @build_log;


my $ROOT = get_cwd();

check_deps();

mkdir("repos");

my $OUTPUT = make_output_dir();
set_cwd($ROOT);


get_code();

my $attiny_bootloader_file               = "attiny88_bootloader-" . $git_tags{'attiny_bootloader'} . ".hex";
my $attiny_firmware_with_bootloader_file = "attiny88_firmware_with_bootloader-" . $git_tags{'attiny_firmware'} . ".hex";
my $attiny_firmware_file                 = "attiny88_firmware-" . $git_tags{'attiny_firmware'} . ".hex";
my $attiny_flasher_sketch_dir            = "attiny_flasher-" . $git_tags{'attiny_firmware'};
my $attiny_flasher_sketch_file           = $attiny_flasher_sketch_dir . "/attiny_flasher-" . $git_tags{'attiny_firmware'} . ".ino";
my $atmega_bootloader_file               = "atmega32u4_bootloader-" . $git_tags{'arduino_boards'} . ".hex";
my $atmega_firmware_file                 = "atmega32u4_firmware-" . $git_tags{'Model01-Firmware'} . ".hex";
my $atmega_firmware_with_bootloader_file = "atmega32u4_firmware_with_bootloader-" . $git_tags{'Model01-Firmware'} . ".hex";

build_attiny_bootloader();
build_attiny_firmware();
build_atmega_bootloader();
build_atmega_firmware();
describe_build();
sub get_code {

    # Check out repos as of tag $TAG:
    for my $repo_name ( keys %repos ) {
        set_cwd($ROOT);
        my $repo_path = "repos/" . $repo_name;
        if ( !-d $repo_path . "/.git" ) {
            git( 'clone', $repos{$repo_name}, $repo_path );
            set_cwd($repo_path);
        }
        else {
            set_cwd($repo_path);
            git('pull');
        }
        git( qw/ checkout/, $args{'--tag'} );
        git(qw/ submodule update --init --recursive/);
        git(qw/clean -xdf/);
        my $tag = git(qw"describe --abbrev=16 --dirty --always");
        chomp($tag);
        $git_tags{$repo_name} = $tag;
    }
}


sub describe_build {
	set_cwd($OUTPUT);
	open(my $out, ">","BUILD_DETAILS.txt");

	print $out "Firmware build completed at ".scalar gmtime()."\n";
	print $out "\n\n";


	print $out "="x60 . "\n";
	print $out "\n\nBuild Log:\n";
	print $out join("\n",@build_log);


	print $out "="x60 . "\n";
	for my $key (keys %git_tags) {
		print $out 
			"Repository:  " .$key."\n".
			"Repo URL:    ".$repos{$key}."\n".
			"Description: ".$git_tags{$key} ."\n\n";
	};
	for my $cmd ('arduino-builder -version', 'avr-gcc -v', 'git --version', 'make -v', 'uname -a', 'hostname') {
	my ($exit, $stdout, $stderr) = run_command(split(/\s+/,$cmd));
	print $out "\n\n";
	print $out "'$cmd':\n";
	
	print $out $stdout || $stderr;
	} 


	close $out;
	set_cwd($ROOT);
}

sub build_attiny_bootloader {

    set_cwd( $ROOT . "repos/attiny_bootloader/TWI_Slave" );
    make(qw"all");
    make_output( "twi_slave.hex", $attiny_bootloader_file );
}

sub build_attiny_firmware {

    set_cwd( $ROOT . "repos/attiny_firmware" );
    copy( $OUTPUT . $attiny_bootloader_file, "etc/bootloader.hex" );
    make("all");
    make("flashing-tool");
    mkdir( $OUTPUT . $attiny_flasher_sketch_dir );
    make_output( "out/flasher/flasher.ino", $attiny_flasher_sketch_file );

    make_output( "out/attiny88_factory.hex",    $attiny_firmware_with_bootloader_file );
    make_output( "out/attiny88_keyscanner.hex", $attiny_firmware_file );

}

sub build_atmega_bootloader {

    set_cwd( $ROOT . "repos/arduino_boards/bootloaders/caterina" );
    make("all");
    make_output( "Caterina.hex" => $atmega_bootloader_file );

}

sub build_atmega_firmware {

    set_cwd( $ROOT . "repos/Model01-Firmware" );
    make("build");
    make( "hex-with-bootloader", "BOOTLOADER_PATH=" . $OUTPUT . $atmega_bootloader_file );

    make_output( "output/Model01-Firmware/Model01-Firmware-latest.hex" => $atmega_firmware_file );

    make_output( "output/Model01-Firmware/Model01-Firmware-latest-with-bootloader.hex" => $atmega_firmware_with_bootloader_file );

}

sub copy {
    my $from = shift;
    my $to   = shift;
    my ( $exitcode, $out, $err ) = run_command( "cp", $from, $to );
}

sub make_output {
    my $from = shift;
    my $to   = shift;
    copy( $from => $OUTPUT . $to );
}

sub git {
    my @commands = (@_);
    my ( $exitcode, $out, $err ) = run_command( 'git', @commands );
    return $out;
}

sub make {
    my @commands = (@_);
    my ( $exitcode, $out, $err ) = run_command( 'make', @commands );
    if ($exitcode) {
        print "Ran command: " . join( " ", 'make', @commands );
        print "$err\n";
    }
    elsif ($err) {
        print "No failure, but still error output:\n\n$err\n";
    }
    else {

    }
}

sub run_command {
    my @cmd = (@_);
    my ( $in, $out, $err, $exitcode );
    print "# ".join(" ",@cmd) ."\n";
    eval {
        IPC::Run::run( \@cmd, \$in, \$out, \$err );

    };
    if ($@) {

        # Could not run the program
        $exitcode = undef;
        die "Could not run command '" . join( " ", @cmd ) . "'\n";
    }
    else {
        $exitcode = $? >> 8;
    }

    print $out. "\n" if ($out);
    print $err. "\n" if ($err);
  

    push @build_log, "# ". join(" ",@cmd);
    if ($exitcode != 0) { 
    push @build_log, "Non-zero exit code: ".$exitcode;
    }
    if ($out) {
    push @build_log, $out;
    }
    if ($err) {
    push @build_log, "STDERR:";
    push @build_log, $err;
	}

    if ( $exitcode != 0 ) {
        die "Exit code $exitcode";
    }
    return ( $exitcode, $out, $err );
}

sub set_cwd {
    my $dir = shift;
    print "# cd $dir\n";
    push @build_log, "# cd $dir";
    chdir($dir);
}

sub get_cwd {
    my $dir = abs_path( cwd() ) . "/";
    return $dir;
}

sub check_deps {
    eval { run_command( 'avr-gcc', '-v' ) };
    if ( my $err = $@ ) {
        die "avr-gcc does not appear to be installed: $err\n";
    }

}

sub make_output_dir {

mkdir("output");
set_cwd("output");
my $datestring = `date -Isec -u`;
chomp($datestring);
$datestring =~s/\+00:00$//;
$datestring =~s /://g;
mkdir($datestring);
if (-l 'latest') {
	run_command('rm', 'latest');
}
symlink $datestring, 'latest';
chdir($datestring);

return get_cwd();
}
