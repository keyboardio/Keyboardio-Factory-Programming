#!/usr/bin/perl

use warnings;
use strict;
use IPC::Run;
use Cwd qw/abs_path cwd/;

my %git_tags;
my @build_log;

my %args = (
	
	'--tag' => undef,	
	
	@ARGV);



if ( !$args{'--tag'} ) {
    die "You need to specifiy a tag or branch name that exists on all four repos in order to build.\n";
}

my %repos = (
    attiny_bootloader  => 'git://github.com/keyboardio/attiny_i2c_bootloader',
    attiny_firmware    => 'git://github.com/keyboardio/avr_keyscanner',
    arduino_boards     => 'git://github.com/keyboardio/Arduino-Boards',
    "Model01-Firmware" => 'git://github.com/keyboardio/Model01-Firmware'
);

my %files = (

	build_details=>  'BUILD_DETAILS.txt',
attiny_bootloader               => "attiny88_bootloader.hex",
attiny_firmware_with_bootloader => "attiny88_firmware_with_bootloader.hex",
attiny_firmware                 => "attiny88_firmware.hex",
attiny_flasher_sketch_dir       => "attiny_flasher",
attiny_flasher_sketch           => "attiny_flasher/attiny_flasher.ino",
atmega_bootloader               => "atmega32u4_bootloader.hex",
atmega_firmware                 => "atmega32u4_firmware.hex",
atmega_firmware_with_bootloader => "atmega32u4_firmware_with_bootloader.hex"

);

my $ROOT = get_cwd();
my $OUTPUT;

eval {

check_deps();

mkdir("repos");

$OUTPUT = make_output_dir();
set_cwd($ROOT);
get_code();
set_output_filenames();
build_attiny_bootloader();
build_attiny_firmware();
build_atmega_bootloader();
build_atmega_firmware();
describe_build();

};

if (my $err = $@) {
	print STDERR "Build failure. Here's the log:\n";
	print STDERR join("\n",@build_log);
	exit -1;
} else {
	print "Build succeeded.\n";
	print "Output directory: ".$OUTPUT."\n";
	print "Build log: ". $OUTPUT."/".$files{'build_details'}."\n";
}




sub get_code {
    # Check out repos as of tag $TAG:
    for my $repo_name ( keys %repos ) {
        set_cwd($ROOT);
        my $repo_path = "repos/" . $repo_name;
        if ( !-d $repo_path . "/.git" ) {
            git( 'clone', $repos{$repo_name}, $repo_path );
            set_cwd($repo_path);
        }
        else {
            set_cwd($repo_path);
            git('pull');
        }
        git( qw/ checkout/, $args{'--tag'} );
        git(qw/ submodule update --init --recursive/);
        git(qw/clean -xdf/);
        my $tag = git(qw"describe --abbrev=16 --dirty --always");
        chomp($tag);
        $git_tags{$repo_name} = $tag;
    }
}


sub describe_build {
	set_cwd($OUTPUT);
	open(my $out, ">", $files{'build_details'});

	print $out "Firmware build completed at ".scalar gmtime()."\n";
	print $out "\n\n";


	print $out "="x60 . "\n";
	for my $key (keys %git_tags) {
		print $out 
			"Repository:  " .$key."\n".
			"Repo URL:    ".$repos{$key}."\n".
			"Description: ".$git_tags{$key} ."\n\n";
	};


	print $out "="x60 . "\n";
	print $out "\n\nBuild Log:\n";
	print $out join("\n",@build_log);

	print $out "\n\n\n\n";
	print $out "="x60 . "\n";


	for my $cmd ('arduino-builder -version', 'avr-gcc -v', 'git --version', 'make -v', 'uname -a', 'hostname') {
	my ($exit, $stdout, $stderr) = run_command(split(/\s+/,$cmd));
	print $out "\n\n";
	print $out "'$cmd':\n";
	
	print $out $stdout || $stderr;
	} 


	close $out;
	set_cwd($ROOT);
}

sub build_attiny_bootloader {

    set_cwd( $ROOT . "repos/attiny_bootloader/TWI_Slave" );
    make(qw"all");
    make_output( "twi_slave.hex", $files{'attiny_bootloader'} );
}

sub build_attiny_firmware {

    set_cwd( $ROOT . "repos/attiny_firmware" );
    copy( $OUTPUT . $files{'attiny_bootloader'}, "etc/bootloader.hex" );
    make("all");
    make("flashing-tool");
    mkdir( $OUTPUT . $files{'attiny_flasher_sketch_dir'} );
    make_output( "out/flasher/flasher.ino", $files{'attiny_flasher_sketch'} );

    make_output( "out/attiny88_factory.hex",    $files{'attiny_firmware_with_bootloader'} );
    make_output( "out/attiny88_keyscanner.hex", $files{'attiny_firmware'} );

}

sub build_atmega_bootloader {

    set_cwd( $ROOT . "repos/arduino_boards/bootloaders/caterina" );
    make("all");
    make_output( "Caterina.hex" => $files{'atmega_bootloader'} );

}

sub build_atmega_firmware {

    set_cwd( $ROOT . "repos/Model01-Firmware" );
    make("build");
    make( "hex-with-bootloader", "BOOTLOADER_PATH=" . $OUTPUT . $files{'atmega_bootloader'} );

    make_output( "output/Model01-Firmware/Model01-Firmware-latest.hex" => $files{'atmega_firmware'} );

    make_output( "output/Model01-Firmware/Model01-Firmware-latest-with-bootloader.hex" => $files{'atmega_firmware_with_bootloader'} );

}

sub copy {
    my $from = shift;
    my $to   = shift;
    my ( $exitcode, $out, $err ) = run_command( "cp", $from, $to );
}

sub make_output {
    my $from = shift;
    my $to   = shift;
    copy( $from => $OUTPUT . $to );
}

sub git {
    my @commands = (@_);
    my ( $exitcode, $out, $err ) = run_command( 'git', @commands );
    return $out;
}

sub make {
    my @commands = (@_);
    my ( $exitcode, $out, $err ) = run_command( 'make', @commands );
    if ($exitcode) {
        print "Ran command: " . join( " ", 'make', @commands );
        print "$err\n";
    }
    elsif ($err) {
        print "No failure, but still error output:\n\n$err\n";
    }
    else {

    }
}

sub run_command {
    my @cmd = (@_);
    my ( $in, $out, $err, $exitcode );
    print "# ".join(" ",@cmd) ."\n";
    eval {
        IPC::Run::run( \@cmd, \$in, \$out, \$err );

    };
    if ($@) {

        # Could not run the program
        $exitcode = undef;
        die "Could not run command '" . join( " ", @cmd ) . "'\n";
    }
    else {
        $exitcode = $? >> 8;
    }

    print $out. "\n" if ($out && $args{'--debug'});
    print $err. "\n" if ($err && $args{'--debug'});
  

    push @build_log, "# ". join(" ",@cmd);
    if ($exitcode != 0) { 
    push @build_log, "Non-zero exit code: ".$exitcode;
    }
    if ($out) {
    push @build_log, $out;
    }
    if ($err) {
    push @build_log, "STDERR:";
    push @build_log, $err;
	}

    if ( $exitcode != 0 ) {
        die "Exit code $exitcode";
    }
    return ( $exitcode, $out, $err );
}

sub set_cwd {
    my $dir = shift;
    print "# cd $dir\n";
    push @build_log, "# cd $dir";
    chdir($dir);
}

sub get_cwd {
    my $dir = abs_path( cwd() ) . "/";
    return $dir;
}

sub check_deps {
    eval { run_command( 'avr-gcc', '-v' ) };
    if ( my $err = $@ ) {
        die "avr-gcc does not appear to be installed: $err\n";
    }

}

sub make_output_dir {

mkdir("output");
set_cwd("output");
my $datestring = `date -Isec -u`;
chomp($datestring);
$datestring =~s/\+00:00$//;
$datestring =~s /://g;
mkdir($datestring);
if (-l 'latest') {
	run_command('rm', 'latest');
}
symlink $datestring, 'latest';
chdir($datestring);

return get_cwd();
}

sub set_output_filenames {
if ($args{'--hashes-in-file-names'}) {
$files{'attiny_bootloader'}               = "attiny88_bootloader-" . $git_tags{'attiny_bootloader'} . ".hex";
$files{'attiny_firmware_with_bootloader'} = "attiny88_firmware_with_bootloader-" . $git_tags{'attiny_firmware'} . ".hex";
$files{'attiny_firmware'}                 = "attiny88_firmware-" . $git_tags{'attiny_firmware'} . ".hex";
$files{'attiny_flasher_sketch_dir'}       = "attiny_flasher-" . $git_tags{'attiny_firmware'};
$files{'attiny_flasher_sketch'}           = $files{'attiny_flasher_sketch_dir'} . "/attiny_flasher-" . $git_tags{'attiny_firmware'} . ".ino";
$files{'atmega_bootloader'}               = "atmega32u4_bootloader-" . $git_tags{'arduino_boards'} . ".hex";
$files{'atmega_firmware'}                 = "atmega32u4_firmware-" . $git_tags{'Model01-Firmware'} . ".hex";
$files{'atmega_firmware_with_bootloader'} = "atmega32u4_firmware_with_bootloader-" . $git_tags{'Model01-Firmware'} . ".hex";
}
}
