#!/usr/bin/perl

use warnings;
use strict;
use IPC::Run;
use Cwd qw/abs_path cwd/;

my $tag = shift @ARGV;

if ( !$tag ) {
    die "You need to specifiy a tag or branch name that exists on all four repos in order to build.\n";
}

my %repos = (
    attiny_bootloader  => 'git://github.com/keyboardio/attiny_i2c_bootloader',
    attiny_firmware    => 'git://github.com/keyboardio/avr_keyscanner',
    arduino_boards     => 'git://github.com/keyboardio/Arduino-Boards',
    "Model01-Firmware" => 'git://github.com/keyboardio/Model01-Firmware'
);

my %git_tags;

my $ROOT = get_cwd();

check_deps();

mkdir("repos");
mkdir("output");
set_cwd("output");
my $OUTPUT = get_cwd();

set_cwd("..");

get_code();

my $attiny_bootloader_file               = "attiny88_bootloader-" . $git_tags{'attiny_bootloader'} . ".hex";
my $attiny_firmware_with_bootloader_file = "attiny88_firmware_with_bootloader-" . $git_tags{'attiny_firmware'} . ".hex";
my $attiny_firmware_file                 = "attiny88_firmware-" . $git_tags{'attiny_firmware'} . ".hex";
my $attiny_flasher_sketch_dir            = "attiny_flasher-" . $git_tags{'attiny_firmware'};
my $attiny_flasher_sketch_file           = $attiny_flasher_sketch_dir . "/attiny_flasher-" . $git_tags{'attiny_firmware'} . ".ino";
my $atmega_bootloader_file               = "atmega32u4_bootloader-" . $git_tags{'arduino_boards'} . ".hex";
my $atmega_firmware_file                 = "atmega32u4_firmware-" . $git_tags{'Model01-Firmware'} . ".hex";
my $atmega_firmware_with_bootloader_file = "atmega32u4_firmware_with_bootloader-" . $git_tags{'Model01-Firmware'} . ".hex";

build_attiny_bootloader();
build_attiny_firmware();
build_atmega_bootloader();
build_atmega_firmware();

sub get_code {

    # Check out repos as of tag $TAG:
    for my $repo_name ( keys %repos ) {
        set_cwd($ROOT);
        my $repo_path = "repos/" . $repo_name;
        if ( !-d $repo_path . "/.git" ) {
            git( 'clone', $repos{$repo_name}, $repo_path );
            set_cwd($repo_path);
        }
        else {
            set_cwd($repo_path);
            git('pull');
        }
        git( qw/ checkout/, $tag );
        git(qw/ submodule update --init --recursive/);
        git(qw/clean -xdf/);
        my $tag = git(qw"describe --abbrev=6 --dirty --always");
        chomp($tag);
        $git_tags{$repo_name} = $tag;
    }
}

sub build_attiny_bootloader {

    set_cwd( $ROOT . "repos/attiny_bootloader/TWI_Slave" );
    make(qw"all");
    make_output( "twi_slave.hex", $attiny_bootloader_file );
}

sub build_attiny_firmware {

    set_cwd( $ROOT . "repos/attiny_firmware" );
    copy( $OUTPUT . $attiny_bootloader_file, "etc/bootloader.hex" );
    make("all");
    make("flashing-tool");
    mkdir( $OUTPUT . $attiny_flasher_sketch_dir );
    make_output( "out/flasher/flasher.ino", $attiny_flasher_sketch_file );

    make_output( "out/attiny88_factory.hex",    $attiny_firmware_with_bootloader_file );
    make_output( "out/attiny88_keyscanner.hex", $attiny_firmware_file );

}

sub build_atmega_bootloader {

    set_cwd( $ROOT . "repos/arduino_boards/bootloaders/caterina" );
    make("all");
    make_output( "Caterina.hex" => $atmega_bootloader_file );

}

sub build_atmega_firmware {

    set_cwd( $ROOT . "repos/Model01-Firmware" );
    make("build");
    make( "hex-with-bootloader", "BOOTLOADER_PATH=" . $OUTPUT . $atmega_bootloader_file );

    make_output( "output/Model01-Firmware/Model01-Firmware-latest.hex" => $atmega_firmware_file );

    make_output( "output/Model01-Firmware/Model01-Firmware-latest-with-bootloader.hex" => $atmega_firmware_with_bootloader_file );

}

sub copy {
    my $from = shift;
    my $to   = shift;
    my ( $exitcode, $out, $err ) = run_command( "cp", $from, $to );
}

sub make_output {
    my $from = shift;
    my $to   = shift;
    copy( $from => $OUTPUT . $to );
}

sub git {
    my @commands = (@_);
    my ( $exitcode, $out, $err ) = run_command( 'git', @commands );
    return $out;
}

sub make {
    my @commands = (@_);
    my ( $exitcode, $out, $err ) = run_command( 'make', @commands );
    if ($exitcode) {
        print "Ran command: " . join( " ", 'make', @commands );
        print "$err\n";
    }
    elsif ($err) {
        print "No failure, but still error output:\n\n$err\n";
    }
    else {

    }
}

sub run_command {
    my @cmd = (@_);
    my ( $in, $out, $err, $exitcode );
    print "# ".join(" ",@cmd) ."\n";
    eval {
        IPC::Run::run( \@cmd, \$in, \$out, \$err );

    };
    if ($@) {

        # Could not run the program
        $exitcode = undef;
        die "Could not run command '" . join( " ", @cmd ) . "'\n";
    }
    else {
        $exitcode = $? >> 8;
    }

    print $out. "\n" if ($out);
    print $err. "\n" if ($err);
    if ( $exitcode != 0 ) {
        die "Exit code $exitcode";
    }
    return ( $exitcode, $out, $err );
}

sub set_cwd {
    my $dir = shift;
    print "# cd $dir\n";
    chdir($dir);
}

sub get_cwd {
    my $dir = abs_path( cwd() ) . "/";
    return $dir;
}

sub check_deps {
    eval { run_command( 'avr-gcc', '-v' ) };
    if ( my $err = $@ ) {
        die "avr-gcc does not appear to be installed: $err\n";
    }

}
